<!-- static/index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>shenyan.app: learn japanese 10x faster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        margin: 0;
        padding: 0;
      }
      .logo {
        width: 259.2px;
        height: 144px;
        background: url("/images/logo_small.png") center/contain no-repeat;
        flex: 0 0 auto;
      }
      .logo-text {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
        font-size: 0.78rem;
        font-family: "Optima", "Candara", "Palatino Linotype", "Book Antiqua", serif;
        font-weight: 800;
        color: #3f3f3f;
        font-style: italic;
        line-height: 1.2;
      }
      .logo-text span {
        white-space: nowrap;
      }
      .left-header {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
        margin-bottom: 0.35rem;
      }
      .left-header-top {
        display: flex;
        align-items: center;
        gap: 0.6rem;
      }
      .left-header-bottom {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.6rem;
      }
      .source-title {
        max-width: 150px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .page {
        max-width: 1200px;
        margin: 0 auto;
        padding: 1rem;
      }

      h1 {
        margin-top: 0;
      }

      .layout {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
      }

      .left-panel,
      .right-panel {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 0.75rem;
        box-sizing: border-box;
      }

      .left-stack {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex: 1;
      }

      .left-panel {
        flex: 0 0 33vh; /* about one third of viewport height */
        max-height: 33vh;
        overflow-y: auto;
        background: #fafafa;
        white-space: pre-wrap;
        line-height: 1.6;
        font-size: 0.9rem;
        color: #888;
        padding: 0.75rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
      }

      .vocab-panel {
        flex: 1;
        min-height: 0;
        background: #f7f9fc;
        padding: 0.75rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        overflow-y: auto;
      }

      .right-panel {
        flex: 2;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
      }
      .current-highlight {
        color: #111;
        font-weight: 600;
      }

      :root {
        --sentence-scale: 1;
      }

      .sentence-box {
        border: 1px solid #f7cfa0;
        border-radius: 8px;
        padding: 1rem;
        min-height: 0;
        max-height: 40vh;
        overflow-y: auto;
        background: linear-gradient(145deg, #fff7ee, #ffe9cf);
        white-space: pre-wrap;
        line-height: calc(1.9 * var(--sentence-scale));
        font-size: calc(1.28rem * var(--sentence-scale));
        font-family: "Noto Serif JP", "Hiragino Mincho ProN", "Yu Mincho", serif;
        box-shadow: 0 4px 14px rgba(0, 0, 0, 0.06);
      }

      .controls {
        margin-top: 0.75rem;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
      }

      button {
        padding: 0.5rem 0.9rem;
        font-size: 0.95rem;
        cursor: pointer;
        border: 1px solid #ccc;
        background: #f7f7f7;
      }
      #speak-sentence.play-btn {
        width: 38px;
        height: 38px;
        padding: 0;
        border: none;
        background: transparent url("/images/play_button_glowing_green_small.png") center/contain no-repeat;
        box-shadow: none;
        position: relative;
        font-size: 0;
        text-indent: -9999px;
      }
      .controls button:not(#speak-sentence):not(.icon-btn) {
        height: 38px;
        width: 52px;
        min-width: 52px;
        padding: 0 0.45rem;
        font-size: 16px;
        line-height: 1;
      }
      .icon-btn {
        width: 76px;
        min-width: 76px;
        height: 38px;
        padding: 0;
        border: none;
        background: transparent center/contain no-repeat;
      }
      .icon-btn.hanaso-btn {
        width: 152px;
        min-width: 152px;
        height: 76px;
        background-image: url("/images/hanaso_trimmed.png");
      }
      .icon-btn.icon-active {
        animation: hanaso-pulse 1.4s ease-in-out infinite;
        filter: drop-shadow(0 0 10px rgba(0, 180, 90, 0.65));
      }
      @keyframes hanaso-pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.03);
        }
        100% {
          transform: scale(1);
        }
      }
      .controls select {
        height: 38px;
        padding: 0 0.45rem;
        font-size: 0.82rem;
        line-height: 1;
      }
      #speak-sentence.play-btn::before {
        content: none;
      }

      .mini-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.85rem;
        margin-left: 0.25rem;
        line-height: 1.15;
      }
      /* keep action buttons uniform size */
      .mini-btn.deep-btn,
      .mini-btn.delete-btn,
      .mini-btn.deep-manual,
      .mini-btn.delete-manual {
        padding: 0.24rem 0.15rem;
        font-size: 0.85rem;
        min-width: 52px;
        width: 52px;
        box-sizing: border-box;
        text-align: center;
        vertical-align: middle;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1.15;
        white-space: nowrap;
      }

      .btn-active {
        background: #d9ebff;
        border-color: #9cc5f7;
        color: #0b3c7d;
      }

      #status {
        margin-top: 0.5rem;
        font-size: 0.85rem;
        color: #555;
      }
      .realtime-status {
        padding: 0.5rem 0.65rem;
        border-radius: 10px;
        background: #f7f7f7;
        border: 1px dashed #bbb;
        color: #333;
        font-size: 0.92rem;
      }

      audio {
        margin-top: 0.75rem;
        width: 100%;
      }

      .hard-item {
        margin-top: 0.5em;
        line-height: 1.4;
      }
      .hint-native {
        margin-left: 0.35rem;
        color: #666;
        font-size: 0.88em;
      }
      .hint-native-pill {
        display: inline-block;
        margin-left: 0.35rem;
        margin-right: 0.25rem;
        padding: 0.08rem 0.4rem;
        font-size: 0.72em;
        border-radius: 999px;
        background: #f0f4ff;
        border: 1px solid #d5e2ff;
        color: #3a4a6b;
        vertical-align: middle;
      }

      .example-card {
        margin-top: 0.4rem;
        padding: 0.55rem 0.65rem;
        border-radius: 10px;
        background: linear-gradient(135deg, #ffe8c7, #ffd8a8);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
        border-left: 4px solid #ff9f43;
        display: flex;
        align-items: flex-start;
        gap: 0.45rem;
      }

      .example-jp {
        font-size: 1rem;
        font-weight: 600;
        color: #2f1b00;
        letter-spacing: 0.01em;
      }

      .example-en {
        margin-top: 0.15rem;
        font-size: 0.9rem;
        color: #5c4a3a;
      }

      .example-play {
        width: 42px;
        height: 30px;
        border: 1px solid #111;
        border-radius: 8px;
        background: linear-gradient(135deg, #e6f5ff, #7fcaff);
        position: relative;
        padding: 0;
        flex-shrink: 0;
      }
      .example-play::before {
        content: "";
        position: absolute;
        inset: 3px 4px;
        background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='96' height='48' viewBox='0 0 96 48'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%' y1='0%' x2='100%' y2='100%'%3E%3Cstop offset='0%' stop-color='%23a7e3ff'/%3E%3Cstop offset='100%' stop-color='%2335a5ff'/%3E%3C/linearGradient%3E%3C/defs%3E%3Cpolygon points='38,10 38,38 66,24' fill='url(%23g)' stroke='%23111' stroke-width='0.4'/%3E%3C/svg%3E") center/95% no-repeat;
      }

      .deep-brief {
        font-weight: 700;
        color: #2f1b00;
        margin-bottom: 0.35rem;
      }
      .word-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        margin-bottom: 0.25rem;
      }
      .word-main {
        font-weight: 700;
        font-size: 1.05rem;
      }
      .native-block {
        margin-top: 0.75rem;
        padding-top: 0.6rem;
        border-top: 1px dashed #e0e0e0;
      }
      .native-label {
        font-size: 0.85rem;
        color: #555;
        margin-bottom: 0.35rem;
      }

      .deep-block {
        margin-top: 0.75rem;
        padding: 0.75rem;
        border: 1px solid #e4e4e4;
        border-radius: 10px;
        background: #fff;
        max-height: 40vh;
        overflow-y: auto;
      }

      .deep-close {
        border: 1px solid #ccc;
        background: #f7f7f7;
        padding: 0.25rem 0.5rem;
        font-size: 0.85rem;
        border-radius: 6px;
        cursor: pointer;
        float: right;
        margin-left: 0.5rem;
      }

      @media (max-width: 800px) {
        .layout {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="layout">
        <!-- LEFT: full text -->
        <div class="left-stack">
          <div class="left-header">
            <div class="left-header-top">
              <div class="logo" aria-label="logo"></div>
              <div class="logo-text" aria-label="tagline">
                <span>Learn Japanese 10x faster</span>
                <span>日语学习速度提升10倍</span>
                <span>일본어를 10배 빠르게 배우세요</span>
              </div>
            </div>
            <div class="left-header-bottom">
              <div id="source-title" class="source-title" style="font-weight:600;">本文</div>
              <div style="display:flex; gap:0.35rem; align-items:center;">
                <button id="sources-btn" class="mini-btn">資料一覧</button>
                <button id="prev-sentence" class="mini-btn">前の文</button>
                <button id="next-sentence" class="mini-btn">次の文</button>
              </div>
            </div>
          </div>
          <div class="left-panel" id="full-text">
            Loading text...
          </div>
          <div class="vocab-panel">
            <div id="hardest-items" class="hard-block"></div>
          </div>
        </div>

        <!-- RIGHT: sentence + controls -->
        <div class="right-panel">
          <!-- <h2>Current Sentence</h2> -->
          <div class="controls">
            <button id="speak-sentence" class="play-btn" aria-label="再生" title="再生">再生</button>
            <select id="voice-select" aria-label="voice" style="padding:0.45rem 0.6rem;">
              <option value="nova">nova</option>
              <option value="sage">sage</option>
              <option value="cedar">cedar</option>
              <option value="onyx">onyx</option>
            </select>
          <button id="vocab-button">単語</button>
          <button id="reset-sentence">削除</button>
          <button id="add-vocab">追加</button>
          <button id="toggle-fg" title="ふりがな">振</button>
          <button id="toggle-hiragana" title="ひらがな">あ</button>
          <button id="translate-btn">Translate</button>
          <button id="vocab-list-btn">語彙</button>
          <button id="realtime-btn" class="icon-btn hanaso-btn" title="話そう" aria-label="話そう"></button>
          </div>
          <div id="sentence-meta" style="font-size: 0.85rem; color: #666">
            文 <span id="sentence-index">-</span> / <span id="sentence-total">-</span>
          </div>
          <div id="current-sentence" class="sentence-box">
            Loading sentence...
          </div>
          <div id="translation-sentence" style="margin-top:0.35rem; color:#444; font-size:1rem; white-space: pre-wrap;"></div>
          <div id="hiragana-sentence" style="margin-top: 0.35rem; color: #666; font-size: 0.95rem;"></div>

          <div id="status"></div>

          <audio id="player" controls></audio>
          <audio id="realtime-audio" autoplay style="display:none;"></audio>

          <div id="deep-dive" class="deep-block"></div>
        </div>
      </div>
    </div>

    <script>
      const fullTextEl = document.getElementById("full-text");
      const currentSentenceEl = document.getElementById("current-sentence");
      const hiraganaEl = document.getElementById("hiragana-sentence");
      const translationEl = document.getElementById("translation-sentence");
      const sentenceIndexEl = document.getElementById("sentence-index");
      const sentenceTotalEl = document.getElementById("sentence-total");
      const statusEl = document.getElementById("status");
      const player = document.getElementById("player");
      const hardestEl = document.getElementById("hardest-items");
      const deepDiveEl = document.getElementById("deep-dive");
      const sourceTitleEl = document.getElementById("source-title");
      const toggleHiraBtn = document.getElementById("toggle-hiragana");
      const toggleFgBtn = document.getElementById("toggle-fg");
      const vocabBtn = document.getElementById("vocab-button");
      const resetBtn = document.getElementById("reset-sentence");
      const vocabListBtn = document.getElementById("vocab-list-btn");
      const addVocabBtn = document.getElementById("add-vocab");
      const sourcesBtn = document.getElementById("sources-btn");
      const voiceSelect = document.getElementById("voice-select");
      const translateBtn = document.getElementById("translate-btn");
      const realtimeBtn = document.getElementById("realtime-btn");
      const realtimeAudio = document.getElementById("realtime-audio");

      const speakBtn = document.getElementById("speak-sentence");
      const prevBtn = document.getElementById("prev-sentence");
      const nextBtn = document.getElementById("next-sentence");

      const SPEED_DEFAULT = 1.1;
      let currentIndex = 0;
      let currentSentence = "";
      let totalSentences = 0;
      let sentencesData = [];
      let showHiragana = false;
      let currentItems = [];
      let currentReading = "";
      let currentRuby = "";
      let showVocab = false;
      let showFurigana = false;
      let currentDeepDive = null;
      let currentManualItems = [];
      const params = new URLSearchParams(window.location.search);
      let selectedSource = params.get("source") || "";
      if (selectedSource) {
        // if an encoded path was provided, decode it
        selectedSource = decodeURIComponent(selectedSource);
      }
      let startIndex = Number.parseInt(params.get("idx") || "0");
      if (Number.isNaN(startIndex) || startIndex < 0) startIndex = 0;
      let currentVoice = voiceSelect.value || "nova";
      let currentSpeed = SPEED_DEFAULT;
      let currentUserName = "Rusty";
      let nativeLang = "en";
      let showNativeDefs = true;
      let currentTranslation = "";
      let showTranslation = false;
      let realtimeActive = false;
      let realtimePc = null;
      let realtimeStream = null;
      let realtimeDc = null;
      let sourceTitleMap = {};

      async function loadSentences() {
        try {
          const res = await fetch(`/api/sentences${selectedSource ? `?source=${encodeURIComponent(selectedSource)}` : ""}`);
          if (!res.ok) {
            fullTextEl.textContent = "Error loading sentences.";
            return;
          }
          const data = await res.json();
          sentencesData = data.sentences || [];
          renderSentenceList();
        } catch (err) {
          console.error(err);
          fullTextEl.textContent = "Error loading sentences.";
        }
      }

      function resolveSourceTitle(sourceKey) {
        if (!sourceKey) return "";
        if (sourceTitleMap[sourceKey]) return sourceTitleMap[sourceKey];
        const base = sourceKey.split(/[\\/]/).pop();
        for (const [path, title] of Object.entries(sourceTitleMap)) {
          if (path.split(/[\\/]/).pop() === base) {
            return title;
          }
        }
        return "";
      }

      function updateSourceTitle() {
        if (!sourceTitleEl) return;
        const title = resolveSourceTitle(selectedSource);
        sourceTitleEl.textContent = title || "本文";
      }

      async function loadSourceTitles() {
        try {
          const res = await fetch("/api/source_list");
          if (!res.ok) return;
          const data = await res.json();
          const list = data.sources || [];
          sourceTitleMap = {};
          for (const s of list) {
            if (s.path) {
              sourceTitleMap[s.path] = s.name || s.path;
            }
          }
          updateSourceTitle();
        } catch (err) {
          console.error("source list load error", err);
        }
      }

      async function loadSentence(index) {
        try {
          const res = await fetch(`/api/sentence/${index}${selectedSource ? `?source=${encodeURIComponent(selectedSource)}` : ""}`);
          if (!res.ok) {
            if (res.status === 404) {
              statusEl.textContent = "No more sentences.";
            } else {
              statusEl.textContent = "Error loading sentence.";
            }
            return;
          }
          const data = await res.json();
          currentIndex = data.index;
        currentSentence = data.sentence;
        totalSentences = data.total;

        currentSentenceEl.textContent = currentSentence;
        hiraganaEl.textContent = "";
        currentReading = "";
        currentRuby = "";
        currentDeepDive = null;
        showFurigana = false;
        showHiragana = false;
        showTranslation = false;
        toggleFgBtn.textContent = "振";
        setActive(toggleFgBtn, false);
        toggleHiraBtn.textContent = "あ";
        setActive(toggleHiraBtn, false);
        setActive(translateBtn, false);
        currentTranslation = "";
        translationEl.textContent = "";
        translationEl.style.display = "none";
        hiraganaEl.style.display = showHiragana ? "block" : "none";
        sentenceIndexEl.textContent = currentIndex + 1; // 1-based for humans
        sentenceTotalEl.textContent = totalSentences;
        statusEl.textContent = "";
        renderFullTextHighlight(currentSentence);
        scrollHighlightIntoView();
        renderSentenceDisplay();
        clearVocabPanels();
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Error loading sentence.";
        }
      }

      async function speakCurrentSentence() {
        if (!currentSentence) {
          statusEl.textContent = "No sentence loaded.";
          return;
        }

        statusEl.textContent = "Generating audio...";
        speakBtn.disabled = true;

        try {
          const res = await fetch("/api/tts", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              text: currentSentence,
              voice: currentVoice,
              speed: currentSpeed,
              model: "gpt-4o-mini-tts",
            }),
          });

          console.log("TTS HTTP status:", res.status);

          if (!res.ok) {
            const txt = await res.text().catch(() => "");
            console.error("TTS server error body:", txt);
            statusEl.textContent = "Error from TTS server: " + txt;
            return;
          }

          const blob = await res.blob();
          console.log("TTS blob size:", blob.size);

          const url = URL.createObjectURL(blob);
          player.src = url;
          try {
            await player.play();
            statusEl.textContent = "Playing.";
          } catch (err) {
            console.error("Audio play error:", err);
            statusEl.textContent = "Audio generated but could not be played.";
          }
        } catch (err) {
          console.error("Fetch / TTS error:", err);
          statusEl.textContent = "Error generating or playing audio.";
        } finally {
          speakBtn.disabled = false;
        }
      }

      function renderRealtimeStatus(message) {
        deepDiveEl.innerHTML = `<div class="realtime-status">${escapeHtml(message)}</div>`;
      }

      async function stopRealtime(silent = false) {
        realtimeActive = false;
        setActive(realtimeBtn, false);
        if (realtimeDc) {
          try {
            realtimeDc.close();
          } catch (_) {}
          realtimeDc = null;
        }
        if (realtimePc) {
          try {
            realtimePc.getSenders().forEach((s) => s.track && s.track.stop());
            realtimePc.close();
          } catch (_) {}
          realtimePc = null;
        }
        if (realtimeStream) {
          realtimeStream.getTracks().forEach((t) => t.stop());
          realtimeStream = null;
        }
        if (!silent) {
          renderRealtimeStatus("会話を終了しました。");
        }
      }

      async function startRealtime() {
        if (realtimeActive) return;
        currentDeepDive = null;
        deepDiveEl.innerHTML = "";
        setActive(realtimeBtn, true);
        renderRealtimeStatus("接続中…");
        try {
          let stream = null;
          try {
            stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          } catch (err) {
            renderRealtimeStatus("マイクの使用を許可してください。");
            throw err;
          }
          realtimeStream = stream;
          const pc = new RTCPeerConnection();
          realtimePc = pc;
          stream.getTracks().forEach((track) => pc.addTrack(track, stream));
          pc.ontrack = (event) => {
            if (!realtimeAudio) return;
            realtimeAudio.srcObject = event.streams[0];
            realtimeAudio.play().catch(() => {});
          };
          const dc = pc.createDataChannel("oai-events");
          realtimeDc = dc;
          dc.onopen = () => {
            renderRealtimeStatus("会話中…");
            try {
              dc.send(JSON.stringify({ type: "response.create" }));
            } catch (_) {}
          };
          dc.onmessage = (event) => {
            try {
              const msg = JSON.parse(event.data);
              if (msg.type === "error") {
                renderRealtimeStatus("接続エラー");
              }
            } catch (_) {}
          };
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          const selectedVoice = voiceSelect.value || currentVoice;
          currentVoice = selectedVoice || currentVoice;
          const tokenRes = await fetch("/api/realtime_token", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ voice: selectedVoice, user_name: currentUserName }),
          });
          if (!tokenRes.ok) {
            let detail = "";
            try {
              const errJson = await tokenRes.json();
              detail = errJson.detail || errJson.error || "";
            } catch (_) {
              try {
                detail = await tokenRes.text();
              } catch (_) {}
            }
            throw new Error(detail || `token:${tokenRes.status}`);
          }
          const tokenData = await tokenRes.json();
          const clientSecret = tokenData.client_secret || tokenData.value;
          if (!clientSecret) {
            throw new Error("token");
          }
          const sdpRes = await fetch("https://api.openai.com/v1/realtime/calls", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${clientSecret}`,
              "Content-Type": "application/sdp",
            },
            body: offer.sdp,
          });
          if (!sdpRes.ok) {
            let detail = "";
            try {
              detail = await sdpRes.text();
            } catch (_) {}
            throw new Error(detail || `sdp:${sdpRes.status}`);
          }
          const answer = await sdpRes.text();
          await pc.setRemoteDescription({ type: "answer", sdp: answer });
          realtimeActive = true;
          renderRealtimeStatus("会話中…");
        } catch (err) {
          console.error("realtime error:", err);
          const message = err && err.message ? `接続エラー: ${err.message}` : "接続エラー";
          renderRealtimeStatus(message);
          await stopRealtime(true);
        }
      }

      speakBtn.onclick = speakCurrentSentence;
      voiceSelect.onchange = () => {
        currentVoice = voiceSelect.value || "nova";
      };
      realtimeBtn.onclick = async () => {
        if (realtimeActive) {
          await stopRealtime();
        } else {
          await startRealtime();
        }
      };

      toggleHiraBtn.onclick = () => {
        showHiragana = !showHiragana;
        toggleHiraBtn.textContent = "あ";
        setActive(toggleHiraBtn, showHiragana);

        if (showHiragana) {
          if (currentReading) {
            hiraganaEl.textContent = currentReading;
            hiraganaEl.style.display = "block";
          } else {
            hiraganaEl.style.display = "block";
            fetchReading(currentSentence);
          }
        } else {
          hiraganaEl.style.display = "none";
        }
      };

      toggleFgBtn.onclick = async () => {
        showFurigana = !showFurigana;
        toggleFgBtn.textContent = "振";
        setActive(toggleFgBtn, showFurigana);
        if (showFurigana && !currentReading) {
          await fetchReading(currentSentence, true); // suppress HG display
        }
        renderSentenceDisplay();
      };

      vocabBtn.onclick = async () => {
        if (showVocab) {
          hardestEl.innerHTML = "";
          deepDiveEl.innerHTML = "";
          showVocab = false;
          setActive(vocabBtn, false);
          return;
        }
        showVocab = true;
        setActive(vocabBtn, true);
        await fetchHardItems(currentSentence);
      };

      addVocabBtn.onclick = async () => {
        const selection = (window.getSelection && window.getSelection().toString().trim()) || "";
        if (!selection) {
          statusEl.textContent = "単語を選択してください。";
          return;
        }
        // ensure panel visible
        if (!showVocab) {
          showVocab = true;
          setActive(vocabBtn, true);
          hardestEl.innerHTML =
            `<div class="hard-item" style="font-weight:600;">語彙ビルダー</div>`;
        }
        // append placeholder immediately
        const placeholderId = `man-${Date.now()}`;
        appendManualItem({
          id: placeholderId,
          surface: selection,
          hint: "読み込み中…",
          brief: "読み込み中…",
          examples: [],
        });
        try {
          const res = await fetch("/api/manual_brief", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              sentence: currentSentence,
              surface: selection,
              native_lang: showNativeDefs ? nativeLang : "ja",
            }),
          });
          if (!res.ok) throw new Error("deep dive failed");
          const data = await res.json();
          replaceManualItem(placeholderId, {
            surface: selection,
            hint: data.hint_ja || "説明なし",
            hint_native: data.hint_native || "",
            hint_native_lang: data.hint_native_lang || nativeLang,
            brief: data.hint_ja || "説明なし",
            explanation: "", // not fetched yet
            examples: [],
          });
        } catch (err) {
          console.error("manual vocab error:", err);
          replaceManualItem(placeholderId, {
            surface: selection,
            explanation: "取得に失敗しました",
            examples: [],
          });
        }
      };

      prevBtn.onclick = async () => {
        statusEl.textContent = "";
        if (currentIndex <= 0) {
          statusEl.textContent = "Already at the first sentence.";
          return;
        }
        await loadSentence(currentIndex - 1);
      };

      nextBtn.onclick = async () => {
        statusEl.textContent = "";
        await loadSentence(currentIndex + 1);
      };

      vocabListBtn.onclick = () => {
        // persist current sentence index in return URL
        const url = new URL(window.location.href);
        url.searchParams.set("idx", currentIndex.toString());
        const back = encodeURIComponent(url.pathname + url.search + url.hash);
        try {
          localStorage.setItem("last_main_url", url.toString());
        } catch (_) {}
        window.location.href = `/static/vocab-list.html?from=${back}`;
      };

      sourcesBtn.onclick = () => {
        window.location.href = "/static/sources.html";
      };

      resetBtn.onclick = async () => {
        if (!currentSentence) return;
        const ok = window.confirm("この文のキャッシュを削除しますか？");
        if (!ok) return;
        statusEl.textContent = "削除中…";
        try {
          const res = await fetch("/api/sentence/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: currentSentence }),
          });
          if (!res.ok) throw new Error("delete failed");
          // clear local state for this sentence
          currentReading = "";
          currentRuby = "";
          currentDeepDive = null;
          currentItems = [];
          currentTranslation = "";
          showTranslation = false;
          setActive(translateBtn, false);
          translationEl.textContent = "";
          translationEl.style.display = "none";
          hiraganaEl.textContent = "";
          renderSentenceDisplay();
          statusEl.textContent = "削除しました";
        } catch (err) {
          console.error(err);
          statusEl.textContent = "削除に失敗しました";
        }
      };

      hardestEl.addEventListener("click", async (e) => {
        const btn = e.target;
        // deep dive on fetched item
        if (btn.classList.contains("deep-btn")) {
          const idx = parseInt(btn.dataset.idx, 10);
          if (Number.isNaN(idx) || !currentItems[idx]) return;
          await fetchDeepDive(currentItems[idx]);
          return;
        }
        // delete fetched item
        if (btn.classList.contains("delete-btn")) {
          const idx = parseInt(btn.dataset.idx, 10);
          if (Number.isNaN(idx) || !currentItems[idx]) return;
          await deleteFetchedItem(currentItems[idx]);
          return;
        }
        // deep dive manual item
        if (btn.classList.contains("deep-manual")) {
          const mid = btn.dataset.mid;
          const m = currentManualItems.find((x) => x.id === mid);
          if (m) {
            await fetchManualDeepDive(m);
          }
          return;
        }
        // delete manual item
        if (btn.classList.contains("delete-manual")) {
          const mid = btn.dataset.mid;
          currentManualItems = currentManualItems.filter((m) => m.id !== mid);
          renderVocabPanel(currentItems, currentManualItems);
          return;
        }
        // play example audio
        if (btn.classList.contains("example-play")) {
          const text = btn.dataset.text || "";
          const surface = btn.dataset.surface || "";
          if (text) {
            await playExampleAudio(text, surface);
          }
          return;
        }
      });

      // handle example play clicks rendered inside the deep-dive block
      deepDiveEl.addEventListener("click", async (e) => {
        const btn = e.target;
        if (btn.classList.contains("deep-close")) {
          deepDiveEl.innerHTML = "";
          return;
        }
        if (btn.classList.contains("native-btn")) {
          const lang = (nativeLang || "").toLowerCase();
          if (!lang || lang === "ja" || !currentDeepDive) return;
          if (currentDeepDive.showNative) {
            currentDeepDive.showNative = false;
            deepDiveEl.innerHTML = renderDeepDive(currentDeepDive);
            return;
          }
          // toggle on immediately for visual feedback
          currentDeepDive.showNative = true;
          deepDiveEl.innerHTML = renderDeepDive(currentDeepDive);
          if (currentDeepDive.native && currentDeepDive.native.lang === lang) {
            return;
          }
          try {
            const res = await fetch("/api/translate_deep_dive", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                explanation: currentDeepDive.explanation || "",
                examples: currentDeepDive.examples || [],
                target_lang: lang,
              }),
            });
            if (!res.ok) throw new Error("native translate failed");
            const data = await res.json();
            currentDeepDive.native = {
              lang,
              explanation: data.explanation || "",
              examples: Array.isArray(data.examples) ? data.examples : [],
            };
            deepDiveEl.innerHTML = renderDeepDive(currentDeepDive);
          } catch (err) {
            console.error("native translate error:", err);
            currentDeepDive.showNative = false;
            deepDiveEl.innerHTML = renderDeepDive(currentDeepDive);
          }
          return;
        }
        if (btn.classList.contains("example-play")) {
          const text = btn.dataset.text || "";
          const surface = btn.dataset.surface || "";
          if (text) {
            await playExampleAudio(text, surface);
          }
        }
      });

      async function fetchDeepDive(item) {
        deepDiveEl.innerHTML = "読み込み中…";
        try {
          if (!item.reading) {
            item.reading = await fetchWordReading(item.surface);
          }
          const res = await fetch("/api/deep_dive", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sentence: currentSentence, item }),
          });
          if (!res.ok) {
            deepDiveEl.textContent = "取得エラー";
            return;
          }
          const data = await res.json();
          const explanation = data.explanation || "説明なし";
          const examples = Array.isArray(data.examples) ? data.examples.slice(0, 2) : [];
          const brief = item.hint_ja || item.brief || "";
          currentDeepDive = {
            item,
            explanation,
            examples,
            brief,
            native: null,
            showNative: false,
          };
          deepDiveEl.innerHTML = renderDeepDive(currentDeepDive);
        } catch (err) {
          console.error("Deep dive fetch error:", err);
          deepDiveEl.textContent = "取得エラー";
        }
      }

      translateBtn.onclick = async () => {
        if (!currentSentence) return;
        showTranslation = !showTranslation;
        setActive(translateBtn, showTranslation);

        if (showTranslation) {
          if (currentTranslation) {
            translationEl.textContent = currentTranslation;
            translationEl.style.display = "block";
            return;
          }
          statusEl.textContent = "翻訳中…";
          try {
            const res = await fetch("/api/translate_sentence", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ text: currentSentence, target_lang: nativeLang }),
            });
            if (!res.ok) {
              translationEl.textContent = "";
              translationEl.style.display = "none";
              statusEl.textContent = "翻訳エラー";
              showTranslation = false;
              setActive(translateBtn, false);
              return;
            }
            const data = await res.json();
            currentTranslation = data.translation || "";
            translationEl.textContent = currentTranslation;
            translationEl.style.display = "block";
            statusEl.textContent = "";
          } catch (err) {
            console.error(err);
            translationEl.textContent = "";
            translationEl.style.display = "none";
            statusEl.textContent = "翻訳エラー";
            showTranslation = false;
            setActive(translateBtn, false);
          }
        } else {
          translationEl.textContent = "";
          translationEl.style.display = "none";
        }
      };

      async function fetchHardItems(sentence) {
        hardestEl.textContent = "";
        try {
          const res = await fetch("/api/hard_items", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: sentence, native_lang: showNativeDefs ? nativeLang : "ja" }),
          });
          if (!res.ok) {
            hardestEl.textContent = "";
            return;
          }
          const data = await res.json();
          const items = (data.items || []).slice(0, 3);
          if (!items.length) {
            hardestEl.textContent = "";
            currentItems = [];
            return;
          }
          currentItems = items;
          renderVocabPanel(items, currentManualItems);
          deepDiveEl.innerHTML = "";
        } catch (err) {
          console.error("Analyze fetch error:", err);
          hardestEl.textContent = "";
          deepDiveEl.textContent = "";
        }
      }

      async function fetchReading(sentence, suppressHiraDisplay = false) {
        if (!sentence) return;
        try {
          const res = await fetch("/api/reading_sentence", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: sentence }),
          });
          if (!res.ok) return;
          const data = await res.json();
          if (data.reading_hiragana) {
            currentReading = data.reading_hiragana;
            currentRuby = data.reading_ruby || "";
            if (!suppressHiraDisplay) {
              hiraganaEl.textContent = currentReading;
              hiraganaEl.style.display = showHiragana ? "block" : "none";
            }
            renderSentenceDisplay();
          }
        } catch (err) {
          console.error("Reading fetch error:", err);
        }
      }

      function clearVocabPanels() {
        hardestEl.innerHTML = "";
        deepDiveEl.innerHTML = "";
        showVocab = false;
        setActive(vocabBtn, false);
        currentManualItems = [];
      }

      function renderVocabPanel(fetchedItems, manualItems) {
        const header = `<div class="hard-item" style="font-weight:600;">語彙ビルダー</div>`;
        const fetchedHtml = fetchedItems
          .map(
            (i, idx) =>
              `<div class="hard-item"><strong>${i.surface}</strong> ${formatHint(i.hint_ja || i.english_hint || "説明なし", i.hint_native, i.hint_native_lang)} <button class="mini-btn deep-btn" data-idx="${idx}">詳しく</button><button class="mini-btn delete-btn" data-idx="${idx}">削除</button></div>`
          )
          .join("");
        const manualHtml = manualItems
          .map(
            (m) =>
              `<div class="hard-item"><strong>${m.surface}</strong> ${formatHint(cleanHint(m.brief || m.hint || m.explanation || "説明なし", m.surface), m.hint_native, m.hint_native_lang)} <button class="mini-btn deep-manual" data-mid="${m.id}">詳しく</button><button class="mini-btn delete-manual" data-mid="${m.id}">削除</button></div>`
          )
          .join("");
        hardestEl.innerHTML = header + fetchedHtml + manualHtml;
      }

      function renderExamples(examples = [], surfaceForAudio = "", withPlay = true) {
        if (!examples || !examples.length) return "";
        return (
          examples
            .map(
              (ex) =>
                `<div class="example-card${withPlay ? "" : " no-play"}">
                  ${withPlay ? `<button class="example-play" aria-label="play" data-text="${escapeHtml(ex.jp || "")}" data-surface="${escapeHtml(surfaceForAudio)}"></button>` : ""}
                  <div>
                    <div class="example-jp">✦ ${ex.jp || ""}</div>
                    <div class="example-en">${ex.en || ""}</div>
                  </div>
                </div>`
            )
            .join("")
        );
      }

      function appendManualItem(item) {
        currentManualItems.push(item);
        renderVocabPanel(currentItems, currentManualItems);
      }

      function renderManualDeepDive(item) {
        const brief = item.brief || item.hint || "";
        const explanation = item.explanation || item.brief || "説明なし";
        currentDeepDive = {
          item,
          explanation,
          examples: item.examples || [],
          brief,
          native: null,
          showNative: false,
        };
        deepDiveEl.innerHTML = renderDeepDive(currentDeepDive);
      }

      async function fetchManualDeepDive(item) {
        deepDiveEl.innerHTML = "読み込み中…";
        try {
          if (!item.reading) {
            item.reading = await fetchWordReading(item.surface);
          }
          const res = await fetch("/api/deep_dive", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sentence: currentSentence, item: { type: "word", surface: item.surface, base_form: item.surface } }),
          });
          if (!res.ok) throw new Error("deep dive failed");
          const data = await res.json();
          item.explanation = data.explanation || item.explanation || "説明なし";
          item.examples = data.examples || item.examples || [];
          renderManualDeepDive(item);
        } catch (err) {
          console.error("manual deep dive error:", err);
          deepDiveEl.textContent = "Error fetching details.";
        }
      }

      function replaceManualItem(id, newData) {
        currentManualItems = currentManualItems.map((m) =>
          m.id === id
            ? {
                ...m,
                ...newData,
                brief: briefText(cleanHint(newData.hint || newData.brief || newData.explanation || "", m.surface)),
              }
            : m
        );
        renderVocabPanel(currentItems, currentManualItems);
      }

      async function deleteFetchedItem(item) {
        try {
          await fetch("/api/hard_item/delete", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: currentSentence, surface: item.surface }),
          });
        } catch (err) {
          console.error("delete fetched item error:", err);
        }
        currentItems = currentItems.filter((i) => i.surface !== item.surface);
        renderVocabPanel(currentItems, currentManualItems);
      }

      async function playExampleAudio(text, surface) {
        try {
          const res = await fetch("/api/tts_example", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text, surface, voice: currentVoice, speed: currentSpeed }),
          });
          if (!res.ok) {
            deepDiveEl.textContent = "音声取得エラー";
            return;
          }
          const data = await res.json();
          const url = data.audio_url;
          if (!url) return;
          const audio = new Audio(url);
          audio.play().catch(() => {});
        } catch (err) {
          console.error("play example audio error:", err);
        }
      }

      function briefText(text, max = 40) {
        if (!text) return "説明なし";
        return text.length > max ? text.slice(0, max) + "…" : text;
      }

      function cleanHint(hint, surface) {
        if (!hint) return hint;
        try {
          const pattern = new RegExp(`^[「『]?${escapeRegex(surface)}[」』]?[：:】\\s]*`, "u");
          return hint.replace(pattern, "").trim();
        } catch {
          return hint;
        }
      }

      function formatHint(jpHint, nativeHint, nativeLang) {
        const base = escapeHtml(jpHint || "説明なし");
        const lang = (nativeLang || "").toLowerCase();
        if (!showNativeDefs || !nativeHint || !lang || lang === "ja") return base;
        return `${base}<span class="hint-native">${escapeHtml(nativeHint)}</span>`;
      }

      function getNativeLabel() {
        if (!showNativeDefs) return "";
        const lang = (nativeLang || "").toLowerCase();
        if (!lang || lang === "ja") return "";
        if (lang === "en") return "English";
        if (lang === "ko") return "한국어";
        if (lang === "zh") return "中文";
        return lang.toUpperCase();
      }

      function getNativeShortLabel(lang) {
        if (lang === "en") return "ENG";
        if (lang === "ko") return "한국어";
        if (lang === "zh") return "中文";
        return lang.toUpperCase();
      }

      function renderNativeBlock(native) {
        if (!native || !native.explanation) return "";
        const label = getNativeLabel();
        const examples = (native.examples || []).map((t) => ({ jp: t || "", en: "" }));
        const examplesHtml = renderExamples(examples, "", false);
        return `<div class="native-block"><div class="native-label">${escapeHtml(label)}</div><div class="deep-expl">${native.explanation}</div>${examplesHtml}</div>`;
      }

      function renderDeepDive(dd) {
        if (!dd) return "";
        const showNative = !!showNativeDefs && !!dd.showNative && !!dd.native && !!dd.native.explanation;
        const wordHeader = buildWordHeader(dd.item || {}, showNative);
        const headerLine = dd.brief ? `<div class="deep-brief">${dd.brief}</div>` : "";
        const examplesHtml = renderExamples(dd.examples || [], (dd.item && dd.item.surface) || "");
        const nativeHtml = showNative ? renderNativeBlock(dd.native) : "";
        return `<button class="deep-close" aria-label="close">×</button>${wordHeader}${headerLine}<div class="deep-expl">${dd.explanation || ""}</div>${examplesHtml}${nativeHtml}`;
      }

      function renderSentenceDisplay() {
        if (showFurigana && currentRuby) {
          currentSentenceEl.innerHTML = currentRuby;
        } else if (showFurigana && currentReading) {
          currentSentenceEl.innerHTML = buildRuby(currentSentence, currentReading);
        } else {
          currentSentenceEl.textContent = currentSentence;
        }
      }

      async function fetchWordReading(surface) {
        if (!surface) return "";
        try {
          const res = await fetch("/api/reading_word", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ surface }),
          });
          if (!res.ok) return "";
          const data = await res.json();
          return data.reading || "";
        } catch (err) {
          console.error("reading word error", err);
          return "";
        }
      }

      function buildWordHeader(item, isNativeActive = false) {
        const base = item.base_form || item.surface || "";
        const reading = item.reading || base || "";
        const label = getNativeLabel();
        const nativeBtn =
          label && nativeLang !== "ja"
            ? `<button class="mini-btn native-btn${isNativeActive ? " btn-active" : ""}" data-action="native-translate">${escapeHtml(label)}</button>`
            : "";
        return `<div class="word-header"><div class="word-main">${escapeHtml(base)}<span style="margin-left:0.4rem; color:#666; font-size:0.95rem;">${escapeHtml(reading)}</span></div>${nativeBtn}</div>`;
      }

      function setActive(btn, isActive) {
        if (!btn) return;
        if (btn.classList.contains("icon-btn")) {
          btn.classList.toggle("icon-active", isActive);
          btn.classList.remove("btn-active");
          return;
        }
        if (isActive) {
          btn.classList.add("btn-active");
        } else {
          btn.classList.remove("btn-active");
        }
      }

      function isAnchor(ch) {
        // anchor on punctuation/quotes/whitespace only (exclude kana to keep them inside chunks)
        return /[、。！？「」『』（）〔〕［］\s]/.test(ch);
      }

      function buildRuby(sentence, reading) {
        let si = 0;
        let ri = 0;
        let out = "";
        const s = sentence;
        const r = reading.replace(/\s+/g, ""); // drop stray spaces in reading

        const isKanaOnly = (str) => /^[ぁ-ゟ゠-ヿー]+$/.test(str);
        const hasAscii = (str) => /[A-Za-z0-9]/.test(str);
        const isAsciiChar = (ch) => /[A-Za-z0-9]/.test(ch);
        const isKanaChar = (ch) => /[ぁ-ゟ゠-ヿー]/.test(ch);
        const makeChunk = (rb, rt) => {
          if (!rb.length) return "";
          if (!rt || rb === rt || isKanaOnly(rb) || hasAscii(rb) || hasAscii(rt)) return escapeHtml(rb);
          return `<ruby><rb>${escapeHtml(rb)}</rb><rt>${escapeHtml(rt)}</rt></ruby>`;
        };

        while (si < s.length) {
          // If current surface char is ASCII, emit it plainly and, if reading matches, advance reading too
          if (isAsciiChar(s[si])) {
            out += escapeHtml(s[si]);
            if (ri < r.length && r[ri] === s[si]) {
              ri += 1;
            }
            si += 1;
            continue;
          }

          // Skip whitespace in sentence (keep it as-is)
          if (/\s/.test(s[si])) {
            out += escapeHtml(s[si]);
            si += 1;
            continue;
          }

          // Plain anchor: kana/punct matches directly
          if (ri < r.length && isAnchor(s[si]) && s[si] === r[ri]) {
            out += escapeHtml(s[si]);
            si += 1;
            ri += 1;
            continue;
          }

          // Start a chunk at si
          const start = si;

          // find next anchor in sentence that also appears ahead in reading
          let anchorPosS = s.length;
          let anchorPosR = r.length;
          let tmpSi = si;
          while (tmpSi < s.length) {
            const ch = s[tmpSi];
            if (isAnchor(ch)) {
              const idxR = r.indexOf(ch, ri);
              if (idxR !== -1) {
                anchorPosS = tmpSi;
                anchorPosR = idxR;
                break;
              }
            }
            tmpSi++;
          }

          const surface = s.slice(start, anchorPosS);
          const readingChunk = r.slice(ri, anchorPosR);

          out += makeChunk(surface, readingChunk || surface); // fallback to surface if empty

          si = anchorPosS;
          ri = anchorPosR;
        }
        return out;
      }

      function escapeHtml(str) {
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escapeRegex(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function renderFullTextHighlight(sentence) {
        renderSentenceList(sentence);
      }

      function scrollHighlightIntoView() {
        const target = fullTextEl.querySelector(".current-highlight");
        if (!target) return;
        const container = fullTextEl;
        const alignCenter = () => {
          const containerRect = container.getBoundingClientRect();
          const targetRect = target.getBoundingClientRect();
          const offset = (targetRect.top - containerRect.top) - (containerRect.height / 2 - targetRect.height / 2);
          container.scrollTop = Math.max(0, container.scrollTop + offset);
        };
        requestAnimationFrame(() => {
          alignCenter();
          requestAnimationFrame(alignCenter);
        });
      }

      function renderSentenceList(highlightSentence = "") {
        if (!sentencesData.length) return;
        const html = sentencesData
          .map((s) => {
            const isCurrent = highlightSentence && s.sentence === highlightSentence;
            return `<div class="sentence-row ${isCurrent ? "current-highlight" : ""}" data-idx="${s.index}">${escapeHtml(s.sentence)}</div>`;
          })
          .join("");
        fullTextEl.innerHTML = html;
      }

      fullTextEl.addEventListener("click", async (e) => {
        const row = e.target.closest(".sentence-row");
        if (!row) return;
        const idx = parseInt(row.dataset.idx, 10);
        if (Number.isNaN(idx)) return;
        await loadSentence(idx);
      });

      async function applySettings() {
        try {
          const res = await fetch("/api/settings");
          if (res.ok) {
            const s = await res.json();
            currentVoice = s.default_voice || currentVoice;
            currentSpeed = typeof s.tts_speed === "number" ? s.tts_speed : currentSpeed;
            nativeLang = s.native_lang || nativeLang;
            showNativeDefs = s.show_native_defs !== undefined ? s.show_native_defs : true;
            currentUserName = (s.user_name || currentUserName || "Rusty").trim();
            translateBtn.textContent = getNativeShortLabel(nativeLang) || "Translate";
            if (s.font_scale) {
              document.documentElement.style.setProperty("--sentence-scale", s.font_scale);
            }
            if (!selectedSource && s.default_source) {
              selectedSource = s.default_source;
            }
            if (s.show_fg) {
              showFurigana = true;
              setActive(toggleFgBtn, true);
            }
            if (s.show_hg) {
              showHiragana = true;
              setActive(toggleHiraBtn, true);
            }
            updateSourceTitle();
          }
        } catch (err) {
          console.error("settings load error", err);
        }
      }

      // Initial load
      (async () => {
        await applySettings();
        await loadSourceTitles();
        await loadSentences();
        await loadSentence(startIndex);
      })();
    </script>
  </body>
</html>
